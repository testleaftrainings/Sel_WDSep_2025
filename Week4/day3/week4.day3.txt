6Today's agenda

What is a Plugin? 

 

A plugin is a software add-on that is installed on a program to add a specific feature to an existing computer program. When a program supports plugins, it enables customization. 

In the Eclipse, a plugin like TestNG can be installed to extend its capabilities to manage and run tests more effectively. 

-----------------------------------------------------
Welcome to TestNG : 

TestNG is a testing framework inspired from JUnit and NUnit but introducing some new functionalities that make it more powerful and easier to use, such as:

1) Run your tests in arbitrarily big thread pools with various policies available (all methods in their own thread, one thread per test class, etcâ€¦â€‹).

2) Test that your code is multithread safe.

3) Flexible test configuration.

4) Support for data-driven testing (with @DataProvider).

5) Support for parameters.

6) Powerful execution model (no more TestSuite).

7) Supported by a variety of tools and plug-ins (Eclipse, IDEA, Maven, etcâ€¦â€‹).

8) Embeds BeanShell for further flexibility.

9) Default JDK functions for runtime and logging (no dependencies).

10) Dependent methods for application server testing.


1.1. Requirements


TestNG Upto v7.5: JDK 8.

TestNG v7.6.0 and above: JDK 11 or higher.

TestNG Eclipse Plugin Update Site
Main update site URL: https://testng.org/testng-eclipse-update-site

Versioned update site URL: https://testng.org/testng-eclipse-update-site/

Standard version : https://testng.org/testng-eclipse-update-site/7.4.0



1.2. Introduction


TestNG is a testing framework designed to simplify a broad range of testing needs, from unit testing (testing a class in isolation of the others) to integration testing (testing entire systems made of several classes, several packages and even several external frameworks, such as application servers).

Writing a test is typically a three-step process:

1) Write the business logic of your test and insert TestNG annotations in your code.

2) Add the information about your test (e.g. the class name, the groups you wish to run, etcâ€¦â€‹) in a testng.xml file or in build.xml.

3) Run TestNG.

Steps to start with TestNG: 

Convert normal script into a TestNG script: 

*Remove static keyword from the main method 

*Remove the input arguments(String[] args) 

*Give a meaningful name to the method 

*Add @Test on the top of the method 

**Import from org.testng.annotations. 

*Right click on the testcase Run as-> 1 TestNG Test 


1.3. Documentation


The concepts used in this documentation are as follows:

#<suite>: A suite is represented by one XML file. It can contain one or more tests and is defined by the <suite> tag.

#<test>: A test is represented by <test> and can contain one or more TestNG classes.

#<class>: A TestNG class is a Java class that contains at least one TestNG annotation. It is represented by the <class> tag and can contain one or more test methods.

# A test method is a Java method annotated by @Test in your source


################## Parallel Execution ################################



| `<suite parallel>` | `<test parallel>` | Thread-Control | Execution Flow Type                                             |
| ------------------ | ----------------- | -------------- | --------------------------------------------------------------- |
| `classes`          | (ignored)         | Suite-level    | All classes globally                                            |
| `tests`            | (ignored)         | Suite-level    | Tests run in parallel                                           |
| `none`             | `classes`         | Per test       | Each test runs sequentially, but classes inside run in parallel |
| 'tests'            |  'classes'        | at suite -> Tests |   2*2 = 4                                 |
                                          at test--> classess

------------
âœ… 1. <suite parallel="classes" thread-count="2">

<suite parallel="classes" thread-count="2">
    <test name="Group1">
        <classes>TestClass1 to TestClass5</classes>
    </test>
    <test name="Group2">
        <classes>TestClass6 to TestClass10</classes>
    </test>
</suite>

ðŸ‘‰ TestNG runs all classes in all <test>s, 2 at a time

T1: TestClass1 â†’ TestClass3 â†’ TestClass5 â†’ TestClass7 â†’ TestClass9
T2: TestClass2 â†’ TestClass4 â†’ TestClass6 â†’ TestClass8 â†’ TestClass10


âœ… 2. <suite parallel="tests" thread-count="2">
Each <test> runs in parallel (not classes inside).

<suite parallel="tests" thread-count="2">
    <test name="Group1">
        <classes>TestClass1 to TestClass5</classes>
    </test>
    <test name="Group2">
        <classes>TestClass6 to TestClass10</classes>
    </test>
</suite>

ðŸš€ Execution (both tests start in parallel):
T1: Group1: TestClass1 â†’ TestClass2 â†’ TestClass3 â†’ TestClass4 â†’ TestClass5
T2: Group2: TestClass6 â†’ TestClass7 â†’ TestClass8 â†’ TestClass9 â†’ TestClass10


âœ… 3. <suite parallel="none">, but <test parallel="classes" thread-count="2">

<suite parallel="none">
    <test name="Group1" parallel="classes" thread-count="2">
        <classes>TestClass1 to TestClass5</classes>
    </test>
    <test name="Group2" parallel="classes" thread-count="2">
        <classes>TestClass6 to TestClass10</classes>
    </test>
</suite>

ðŸ“¦ Sequential test groups, but classes inside each test run in parallel

Group1 runs first:
T1: TestClass1 â†’ TestClass3 â†’ TestClass5
T2: TestClass2 â†’ TestClass4

Then Group2:
T1: TestClass6 â†’ TestClass8 â†’ TestClass10
T2: TestClass7 â†’ TestClass9


----------------------------------------------------------------------------------

        
<dependency>
    <groupId>commons-io</groupId>
    <artifactId>commons-io</artifactId>
    <version>2.11.0</version>
</dependency>







// step 1 : we have to choose our file type 
		
// step 2 : we have to create a folder 
// File class-- . /name of the folder / name of the snapshot . image format
		
//step 3 : we are merging the source file with the destination file using the Apache.commons.io.FileUtils

-----------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------


JavascriptExecutor



In Selenium, the JavascriptExecutor interface is used to execute JavaScript code in the context of the browser. Here are the various ways to initialize and use JavascriptExecutor in Selenium Java:

1)Using Explicit Casting
The most common way to initialize JavascriptExecutor is by explicitly casting the WebDriver instance:


    JavascriptExecutor js = (JavascriptExecutor) driver;

2.Direct Use Without a Separate Variable
You can directly cast and use the JavascriptExecutor without assigning it to a variable

    driver.executeScript(String script, Object... args);

        The executeScript() method in Selenium Java allows you to execute custom JavaScript code directly in the browser during test automation(it will directly make the API CALL). This provides flexibility to perform operations that might not be possible using standard Selenium WebDriver APIs. Below are various use cases for executeScript():


1. Interacting with Hidden or Disabled Elements

    Sometimes, elements are not visible or disabled in the DOM but need to be interacted with for testing purposes.

    .executeScript("arguments[0].click();", element);

2. Scrolling the Page

    Scroll the page to a specific position or an element.

        
        .executeScript("arguments[0].scrollIntoView(true);", element);
        .executeScript("window.scrollBy(0,1000);");
            window.scrollBy(x, y) is a JavaScript function that scrolls the document by a given number of pixels relative to the current position:

            x: The number of pixels to scroll horizontally (positive values scroll to the right, negative values to the left).
            y: The number of pixels to scroll vertically (positive values scroll down, negative values scroll up).
            In your example:

            x = 0: No horizontal scrolling.
            y = 1000: Scrolls vertically down by 1000 pixels.


3. Retrieving the Page Title or Other Properties

    Get the page title or other JavaScript-accessible properties.
    String title = (String) ((JavascriptExecutor) driver).executeScript("return document.title;");
    
    System.out.println("Page Title: " + title);

4. Handling Alerts
    Triggering or managing browser alerts.

    driver.executeScript("alert('This is a test alert');");

5. Force Page Refresh or Navigation
    
    Force reload or navigate without using WebDriver.
    driver.executeScript("location.reload();");

6. Manipulating Element Attributes
    
    
    Modify attributes of a DOM element.
    If sendKeys() is not working means we can go with it 

    driver.executeScript("arguments[0].setAttribute('value', 'New Value');", element);


+--------------------------------+------------------------------------------------------------------------+------------------------------------------------+
| Exception Name                 | Reason                                                                | Why JS Click Helps                             |
+--------------------------------+------------------------------------------------------------------------+------------------------------------------------+
| ElementNotInteractableException| Element in DOM but not visible/enabled (hidden, off-screen)           | JS directly triggers click in DOM              |
| ElementClickInterceptedException| Another element (popup, header, loader) overlaps target               | JS bypasses visual obstructions                |
| MoveTargetOutOfBoundsException | Element outside visible screen or not scrolled into view              | JS ignores viewport/screen bounds             |
| StaleElementReferenceException | DOM changed between locating/clicking (works if re-located)           | JS works after re-location                    |
| Timeout waiting for click      | .click() waits for conditions that may never complete (JS-heavy UIs)  | JS skips rendering waits                      |
+--------------------------------+------------------------------------------------------------------------+------------------------------------------------+              |


--------------------------------------------------


